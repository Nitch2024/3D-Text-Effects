<!doctype html>
<html dir="ltr" lang="en">

<head>
    <meta charset="utf-8">
    <title>Text Rendering</title>
    <style>
        body,
        html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        @font-face {
            font-family: "myFont";
            src: url("Lemon Milk Pro.woff2");
        }

        .gradient-text {
            position: absolute;
            left: 0px;
            top: 0px;
            background-image: linear-gradient(180deg, #FFFFFF 37%, #FFDA09 50%, #FF6100 63%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            mix-blend-mode: normal;
        }

        .inner-shadow1 {
            position: absolute;
            content: attr(data-text);
            left: 0px;
            top: 0px;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(180deg, #FFFFFF 37%, #FFDA09 50%, #FF6100 63%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 1.5px 1.5px 2.5px rgba(0, 0, 0, 1);
            mix-blend-mode: plus-lighter;
            filter: brightness(0.4);
        }

        .inner-shadow2 {
            position: absolute;
            content: attr(data-text);
            left: 0px;
            top: 0px;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(180deg, #FFFFFF 37%, #FFDA09 50%, #FF6100 63%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: -1.5px -1.5px 2.5px rgba(0, 0, 0, 1);
            mix-blend-mode: plus-lighter;
            filter: brightness(0.4);
        }

        h1 {
            font-size: 8.5vw;
            text-align: center;
            padding: 0;
            margin: 0;
            width: 100%;
            height: 60vh;
            line-height: 60vh;
            font-family: "myFont";
        }
    </style>
    <script type="text/javascript">
        let posx = 1.0
        let stepx = 1.0
        let posy = 1.0
        let stepy = 1.0

        function project3D(length, blurRad, R1, G1, B1, R2, G2, B2) {
            let res = "";
            for (let depth = 0; depth < length; depth++) {
                res += `${posx}px ${posy}px ${blurRad}px rgb(${depth*(R2-R1)/(length-1)+R1},${depth*(G2-G1)/(length-1)+G1},${depth*(B2-B1)/(length-1)+B1}),`
                posx += stepx;
                posy += stepy;
            }
            return res;
        };

        function contour3D(size, blurRad, R, G, B) {
            let res = "";
            let subdiv = size * 1.5;
            for (let step = 0; step < subdiv; step++) {
                let angle = step * 2 * Math.PI / subdiv;
                let radius = size * stepx / 3.0;
                let dirx = Math.cos(angle);
                let diry = Math.sin(angle);
                let dot = 0.8 + 0.2 * (dirx + diry + Math.sqrt(2)) / (2 * Math.sqrt(2));
                res += `${posx+radius*dirx*dot}px ${posy+radius*diry*dot}px ${blurRad}px rgb(${R},${G},${B}),`;
            }
            posx += stepx;
            posy += stepy;
            return res;
        };

        function StackContour3D(size, length, blurRad, R1, G1, B1, R2, G2, B2) {
            let res = "";
            let subdiv = size * 1.5;
            for (let depth = 0; depth < length; depth++) {
                for (let step = 0; step < subdiv; step++) {
                    let angle = step * 2 * Math.PI / subdiv;
                    let radius = size * stepx / 3.0;
                    let dirx = Math.cos(angle);
                    let diry = Math.sin(angle);
                    let dot = 0.8 + 0.2 * (dirx + diry + Math.sqrt(2)) / (2 * Math.sqrt(2));
                    res += `${posx+radius*dirx*dot}px ${posy+radius*diry*dot}px ${blurRad}px rgb(${depth*(R2-R1)/(length-1)+R1},${depth*(G2-G1)/(length-1)+G1},${depth*(B2-B1)/(length-1)+B1}),`;
                }
                posx += stepx;
                posy += stepy;
            }
            return res;
        };

        function contourShadow3D(size, blurRad, dist, R, G, B, A) {
            let res = "";
            let subdiv = size * 1.5;
            for (let step = 0; step < subdiv; step++) {
                let angle = step * 2 * Math.PI / subdiv;
                let radius = size * stepx / 3.0;
                let dirx = Math.cos(angle);
                let diry = Math.sin(angle);
                let dot = 0.8 + 0.2 * (dirx + diry + Math.sqrt(2)) / (2 * Math.sqrt(2));
                res += `${posx+dist+radius*dirx*dot}px ${posy+dist+radius*diry*dot}px ${blurRad}px rgba(${R},${G},${B},${A}),`;
            }
            posx += stepx;
            posy += stepy;
            return res;
        };
        const sheet = new CSSStyleSheet();
        let style = ".gradient-text::before {"
        style += "content: attr(data-text);"
        style += "position: absolute;"
        style += "left: 0px;"
        style += "top: 0px;"
        style += "width: 100%;"
        style += "height: 100%;"
        style += "z-index: -1;"
        style += "color: #000;"
        style += "text-shadow:"
        style += project3D(6, 0, 99, 6, 6, 160, 1, 3); // 3D Projection 1
        style += `${posx}px ${posy}px 6px rgba(0,0,0,1.0),`; // Projected Shadow onto 3D Contour
        style += `${posx}px ${posy}px 6px rgba(0,0,0,1.0),`; // Projected Shadow onto 3D Contour second time to be darker
        style += contour3D(13, 0, 36, 37, 194); // 3D Contour
        style += StackContour3D(13, 8, 0, 36, 37, 194, 8, 7, 126); // 3D Projection 2 applies to contour
        style += contourShadow3D(13, 15, 8, 16, 16, 16, 0.075); // 3D Contour Shadow
        style += `${posx}px ${posy}px 0px rgba(0,0,0,0.0)`
        style += ";}"
        sheet.replaceSync(style);
        document.adoptedStyleSheets = [sheet];
    </script>
</head>

<body style="background:radial-gradient(ellipse closest-side at center, #ffffff, #8dd0fd);">
	<div style="style="position: absolute; top:10px;">
		<h1 class="gradient-text" data-text="SUPER CSS">SUPER CSS</h1>
		<h1 class="inner-shadow1" data-text="SUPER CSS">SUPER CSS</h1>
		<h1 class="inner-shadow2" data-text="SUPER CSS">SUPER CSS</h1>
	</div>

    <canvas id="myCanvas" width="1920" height="180" style="position: absolute; top:540px; margin: 0; padding: 0; 	font-family:'myFirstFont';"></canvas>
    <script>
        const c = document.getElementById("myCanvas");
        const ctx = c.getContext("2d");
        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        let canvas_posx = 960.0;
        let canvas_posy = 0.0;
        let canvas_startx = 960.0;
        let canvas_starty = 0.0;
        let canvas_angle = 45.0;
        let canvas_stepx = 1.5 * Math.cos(canvas_angle * Math.PI / 180);
        let canvas_stepy = 1.5 * Math.sin(canvas_angle * Math.PI / 180);
        let canvas_text = "SUPER CANVAS";

        function canvas_contourShadow3D(size, blurRad, dist, textColor, shadowColor) {
            ctx.fillStyle = textColor;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = blurRad;
            ctx.shadowOffsetX = dist * canvas_stepx;
            ctx.shadowOffsetY = dist * canvas_stepy;

            let subdiv = size * 1.5;
            for (let step = 0; step < subdiv; step++) {
                let angle = step * 2 * Math.PI / subdiv;
                let radius = size * stepx / 3.0;
                let dirx = Math.cos(angle);
                let diry = Math.sin(angle);
                let dot = 0.8 + 0.2 * (dirx + diry + Math.sqrt(2)) / (2 * Math.sqrt(2));
                ctx.fillText(canvas_text, canvas_posx + radius * dirx * dot, canvas_posy + radius * diry * dot);
            }

            ctx.shadowColor = `rgba(0,0,0,0)`;
        };

        function canvas_stackContour3D(size, length, R1, G1, B1, R2, G2, B2) {
            let subdiv = size * 1.5;
            for (let depth = length; 0 < depth; depth--) {
                ctx.fillStyle = `rgb(${depth*(R2-R1)/(length-1)+R1},${depth*(G2-G1)/(length-1)+G1},${depth*(B2-B1)/(length-1)+B1})`;
                for (let step = 0; step < subdiv; step++) {
                    let angle = step * 2 * Math.PI / subdiv;
                    let radius = size * stepx / 3.0;
                    let dirx = Math.cos(angle);
                    let diry = Math.sin(angle);
                    let dot = 0.8 + 0.2 * (dirx + diry + Math.sqrt(2)) / (2 * Math.sqrt(2));
                    ctx.fillText(canvas_text, canvas_posx + depth * canvas_stepx + radius * dirx * dot, canvas_posy + depth * canvas_stepy + radius * diry * dot);
                }
            }
        };

        function canvas_projectionShadow3D(blurRad, textColor, shadowColor) {
            ctx.fillStyle = textColor;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = blurRad;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fillText(canvas_text, canvas_posx, canvas_posy);
            ctx.shadowColor = `rgba(0,0,0,0)`;
        };

        function canvas_project3D(length, R1, G1, B1, R2, G2, B2) {
            for (let depth = length; 0 < depth; depth--) {
                ctx.fillStyle = `rgb(${depth*(R2-R1)/(length-1)+R1},${depth*(G2-G1)/(length-1)+G1},${depth*(B2-B1)/(length-1)+B1})`;
                ctx.fillText(canvas_text, canvas_posx + canvas_stepx * depth, canvas_posy + canvas_stepy * depth);
            }
        };

        function inner_glow(blur_radius, gradient, offset_x, offset_y) {
            const c2 = document.createElement('canvas');
            c2.width = c.width;
            c2.height = c.height;
            const ctx2 = c2.getContext("2d");
            ctx2.textAlign = ctx.textAlign;
            ctx2.textBaseline = ctx.textBaseline;
            ctx2.font = ctx.font;

            ctx2.fillStyle = gradient;
            ctx2.fillText(canvas_text, canvas_posx, canvas_posy);

            ctx2.filter = `blur(${blur_radius}px)`;
            ctx2.globalCompositeOperation = "source-atop";
            ctx2.fillStyle = "rgba(0, 0, 0, 1.0)";
            ctx2.fillText(canvas_text, canvas_posx + offset_x, canvas_posy + offset_y);

            ctx.globalCompositeOperation = "screen";
            ctx.filter = "brightness(125%)";
            ctx.drawImage(c2, 0, 0);
        };

        async function drawWhenReady() {
            await document.fonts.ready; // Wait for fonts

            ctx.font = "160px myFont";

            // DRAW FRONT TO BACK
			// SHADOW OF CONTOUR, 3D Projected CONTOUR, CONTOUR, Shadow of 3D Projection, 3D Projection, Front with Gradient, Inner Glow
            let contourShadowDistance = 8;
            let contourShadowBlurRad = 15;
            let contourSize = 13;
            let proj2length = 8;
            let proj1length = 6;

            canvas_posx = canvas_startx + (proj1length + proj2length) * canvas_stepx;
            canvas_posy = canvas_starty + (proj1length + proj2length) * canvas_stepy;
            canvas_contourShadow3D(contourSize, contourShadowBlurRad, contourShadowDistance, "rgb(8,7,127)", "rgb(16,16,16,0.075)"); // USE LAST CONTOUR COLOR FOR TEXT

            canvas_posx = canvas_startx + (proj1length) * canvas_stepx;
            canvas_posy = canvas_starty + (proj1length) * canvas_stepy;
            canvas_stackContour3D(contourSize, proj2length, 36, 37, 194, 8, 7, 126); // 3D Projection 2 applies to contour
            canvas_stackContour3D(contourSize, 1, 36, 37, 194, 36, 37, 194); // 3D Contour 
            canvas_projectionShadow3D(6, "rgb(160,1,3)", "rgba(0,0,0,1)"); // Shadow of projection 1 onto contour
            canvas_projectionShadow3D(6, "rgb(160,1,3)", "rgba(0,0,0,1)"); // 2nd time to get the right darkness

            canvas_posx = canvas_startx;
            canvas_posy = canvas_starty;
            canvas_project3D(proj1length, 99, 6, 6, 160, 1, 3); // 3D Projection 1

            const gradient = ctx.createLinearGradient(0, 0, 0, c.height);
            gradient.addColorStop(0.00, "#FFFFFF");
            gradient.addColorStop(0.45, "#FFDA09");
            gradient.addColorStop(0.90, "#FF6100");
            ctx.fillStyle = gradient;
            ctx.fillText(canvas_text, canvas_posx, canvas_posy);

            inner_glow(1.5, gradient, 1.5, 1.5);
            inner_glow(1.5, gradient, -1.5, -1.5);
        }

        drawWhenReady();
    </script>
</body>

</html>